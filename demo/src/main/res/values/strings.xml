<resources>
    <string name="app_name">Shadow Gadgets Demo</string>

    <string name="welcome_header">Welcome to the\n<big><u>Shadow Gadgets Demo</u></big></string>
    <string name="welcome">• There are multiple pages accessible through the spinner menu in the top left that begins with Intro. Though not necessary, you might want to go through them in order, at least the first time, since a few pages build on information from previous ones.\n\n• The switch on the right will be available on certain pages to toggle the fix, to allow you to compare and contrast the effect in the given setups.\n\n• The underlined texts throughout have relevant contextual information, and can be clicked to bring up the full text in a dialog.\n\n• This demo was designed and tested on 1080x1920 xxhdpi devices. Admittedly, several of the layouts were done \"by eye\", and so might have children that do not line up as intended on other configurations. Not much effort has been put into accounting for that, at the moment. Apologies, if that\'s an inconvenience.</string>
    <string name="hide_welcome">Don\'t show this again.</string>

    <string name="intro_top">The switch above is simply calling <tt>view.clipOutlineShadow = isChecked</tt> on the target <tt>View</tt>s on the pages where it\'s available. Everything else on these pages is basically contrived setup geared toward illustrating the runtime effects, rather than the relatively simple code usage.\n\nThese first two Intro sections show plain <tt>View</tt>s with round rectangle backgrounds, alongside controls to vary the elevation and color, so you can play around with those attributes to observe how the shadows behave normally, and to see exactly what these tools are clipping out in fixing them.\n\nNote that the Elevation, Alpha, and Color controls affect only the two targets on this page.</string>
    <string name="intro_bottom">Long-click to drag and drop the target among the three frames.\n\nA main design goal was to have this mimic an inherent <tt>View</tt> property as much as possible, and this demonstrates that the clipped shadow handles moving itself automatically if its target is moved to a new parent. \n\nSince the drag-and-drop is incidental here, this is using only the default <tt>DragShadowBuilder</tt>, so as not to complicate the example unnecessarily.</string>

    <string name="motions_top">This <tt>MotionLayout</tt> is a slight modification to one of the official examples that simply allows you to drag the <tt>View</tt> side to side while it animates some attributes proportionally.\n\nThough it might be difficult to spot with a finger in the way, the clipped shadow can be seen to follow the target and to adjust for its scaling appropriately.</string>
    <string name="motions_bottom">This sample comprises a <tt>CoordinatorLayout</tt> with some <tt>FloatingActionButton</tt>s and a <tt>Snackbar</tt>, to illustrate the behavior with common animations.</string>

    <string name="view_groups_top">The library offers several custom <tt>ViewGroup</tt> subclasses, but the Regular ones basically serve only to help set shadow properties on children at initialization, either through layout inflation or dynamic instantiation. They only have effect on children as they\'re added, and only before the <tt>ViewGroup</tt> is attached to its <tt>Window</tt>. They are used in various places throughout this demo so we won\'t bother with a redundant example here.\n\nThe other main category is the Recycling <tt>ViewGroup</tt>s, and these do provide runtime optimization in that they maintain their children\'s existing shadows, instead of continually creating and destroying them during the attach/detach cycles that happen during scrolling.\n\nThere are several customized platform <tt>AdapterView</tt>s, as well as <tt>RecyclerView</tt>, and since the effect would be the same in all of them, we demonstrate only the last one here.</string>

    <string name="limitations_top">Starting with API level 30, this will only work automatically with <tt>View</tt>s that are circles, rectangles, or regular round rectangles. If you\'re running on an affected version (R or above), you can see the failure with the quarter-round square on the bottom-right.\n\nThe increasing restrictions on non-SDK interfaces introduced in Pie have finally removed access to the <tt>Path</tt> object that describes irregular shapes.\n\nThe next release will have options to work with common Jetpack components – e.g., <tt>ShapeableImageView</tt>, <tt>MaterialShapeDrawable</tt>, etc. – or a user-provided shape. For now, you might be able to use <tt>ShadowDrawable</tt> as a background, as it will still work with arbitrary shapes.</string>
    <string name="limitations_bottom">Aside from the irregular shape issue on R+, the main limitation inherent to the technique is that overlapping sibling <tt>View</tt>s can cause glitches of a different sort, since the replica shadows are basically pulled out of the normal drawing order and overlaid on top, by default.\n\nIt is important to note that this is only an issue for <i>sibling</i> <tt>View</tt>s. Those in separate parent <tt>ViewGroup</tt>s have completely separate draws that will not interfere with each other. Indeed, possibly the most straightforward remedy in some cases is to simply wrap a sibling in another <tt>ViewGroup</tt>, like a plain old <tt>FrameLayout</tt>.\n\nHowever, there are certainly cases where siblings must overlap, so the next two pages briefly describe the issues, and the options available to mitigate them.</string>

    <string name="issues_top">This page is a quick demonstration of the inherent limitations that are the reasons for the other two core properties: <tt>clippedShadowPlane</tt> and <tt>shadowFallbackStrategy</tt>.\n\nThere are no such issues with targets and <tt>View</tt>s in other parents overlapping, as they will have completely separate draws, so if you don\'t really need to overlap targets with siblings anywhere, you might not need to bother with these other properties.\n\nThis top section shows an example of the glitch possible if a target and a sibling overlap. The top-left blue target is z-ordered beneath the red sibling, but its clipped shadow renders on top.</string>
    <string name="issues_bottom">This bottom section is using a fallback drawing method which is automatically selected if the primary one is unavailable on API levels 28 and below, since it\'s using non-SDK interfaces on those versions.\n\nWith this method, the shadows are clipped and drawn all at once rather than individually, so any parts of shadows within the bounds of overlapping targets are clipped, as well. This is evident in the two translucent grey circles below: when clipped, the shadows should be visible underneath each target, on either side of the area of intersection.\n\nThis and overlaid shadow glitch explained above are the reasons for the features outlined on the following page: foreground and background drawing planes, and strategies for fallback behavior.</string>

    <string name="options_top">To help with the described issues, the clipped shadows can be drawn to either the parent <tt>ViewGroup</tt>\'s foreground or background plane.\n\nSince it requires (slightly) less overhead, drawing to the foreground is the default option, but it takes only one more simple property setting to change that: <tt>view.clippedShadowPlane = Background</tt>.\n\nThe setups below show how this might be useful. The setup in the left side would\'ve normally drawn the blue target\'s clipped shadow over the red sibling, but moving it to the background plane prevents that.\n\nThe one on the right is using the fallback method, and avoids its default glitch of missing shadows by virtue of the fact that the siblings are drawing in separate planes.</string>
    <string name="options_bottom">Since the fallback method\'s effect is a bit different, and also requires a bit more overhead, the <tt>shadowFallbackStrategy</tt> property is offered as a means to alter properties at runtime should that method be in effect. The default <tt>None</tt> does nothing, and <tt>ChangePlane</tt> and <tt>DisableShadow</tt> are hopefully self-explanatory.\n\nThe two setups below are identical, with all of the children\'s shadows in the foreground by default, except the right side is using the fallback drawing method.\n\nThe blue target\'s strategy is <tt>ChangePlane</tt> so it can avoid the missing shadows around its intersection with the light grey sibling.\n\nThe red\'s strategy is <tt>DisableShadow</tt>, which has simply turned its shadow off, precluding any such issues with its sibling overlap, and avoiding the (slight) extra overhead from the background plane draw.</string>

    <string name="inflation_top">There\'s not much to see at runtime with these three examples of the layout inflation helpers; their benefit and effect are primarily in the code.\n\nEach <tt>Activity</tt> demonstrates the particular helper class for its configuration, and a different option for defining and setting the tag matchers.\n\nThe UIs themselves are non-functional mock-ups.</string>
    <string name="inflation_bottom">As mentioned on the ViewGroups page, there are several subclasses of Regular <tt>ViewGroup</tt>s – i.e., non-Recycling ones – to help with setting shadow properties on children through layout XML.\n\nThough they both provide essentially the same service, the inflation helpers are meant for cases that require minimal changes to existing layouts, whereas the <tt>ViewGroup</tt>s are meant for layouts that are yet to be written, or that are easily modified.\n\nLike the inflation helpers above, there\'s not much to see at runtime, and there are several examples already available on various pages throughout the demo.</string>

    <string name="colors_top">Starting with API level 28 (Pie), shadows have a couple of attributes available to tint them slightly for colored ambient and spot sources.\n\nHowever, I\'ve never gotten shadow colors to work at all on Pie itself, with or without this library involved. I can\'t find any other mention of the same error, though, so it apparently works for everybody else? I\'m truly baffled by it, at the moment.\n\nAnyway, this may or may not work on your Pie device. It works as expected for subsequent versions.\n\nUnlike the Intro page, the Alpha and Color controls here affect the shadow, rather than the <tt>View</tt>\'s background.</string>
    <string name="colors_bottom">The dummy buttons below simply serve to provide alternate contrast, and to allow you to see these colored shadows during elevation animations. By default, the relevant values contribute only very slight tinting to the base color, and it can be too subtle to notice.\n\nThe elevation setting above is not applied to these buttons, as they have <tt>StateListAnimator</tt>s to control their z-offsets in response to state changes.</string>

    <string name="drawables_top"><tt>ShadowDrawable</tt> is relatively basic, at present, but it does offer another possible fix option if the main one isn\'t working out for you, for whatever reason.\n\nIt might also be useful on its own; e.g., in a custom compound <tt>View</tt> that would normally require several other elevated <tt>View</tt>s added internally.\n\nThough it does require the primary drawing method, every effort has been made to ensure that <tt>ShadowDrawable</tt>, at least, has access to that on every supported API level.\n\nThe example here is using a <tt>fillPaint</tt> with a simple color value to fill the interior.</string>

    <string name="platform_description"><big>Platform <tt>Activity</tt> with <tt>Theme.Material</tt></big>\n\nThis <tt>Activity</tt> uses only platform <tt>View</tt>s. It attaches a helper <tt>Factory</tt> to its <tt>LayoutInflater</tt> before <tt>setContentView()</tt>, and targets any <tt>View</tt> with the <tt>app:clipOutlineShadow</tt> attribute set to <tt>true</tt>.</string>
    <string name="compat_description"><big><tt>AppCompatActivity</tt> with <tt>Theme.AppCompat</tt></big>\n\nThis library <tt>Activity</tt>\'s inflater helper is attached through the <tt>viewInflaterClass</tt> mechanism, and it targets <tt>View</tt>s based on rules defined in a resource XML file.</string>
    <string name="material_description"><big><tt>AppCompatActivity</tt> with <tt>Theme.MaterialComponents</tt></big>\n\nThis <tt>AppCompatActivity</tt> setup attaches the inflater helper and builds the tag matchers programmatically.</string>
    <string name="launch">Launch</string>

    <string name="platform_title"><tt>Activity</tt></string>
    <string name="platform_subtitle"><tt>Theme.Material</tt></string>
    <string name="platform_summary">This layout was modified to add <tt>app:clipOutlineShadow=\"true\"</tt> attributes to the target <tt>View</tt>s, and the helper is attached in the <tt>Activity</tt>\'s <tt>onCreate()</tt> override.\n\nThe <tt>Button</tt>s below are both similar, except the left one is not fixed, and the right one is. The other two <tt>Activity</tt> examples have similar setups to compare.</string>

    <string name="compat_title"><tt>AppCompatActivity</tt></string>
    <string name="compat_subtitle"><tt>Theme.AppCompat</tt></string>
    <string name="compat_summary">This setup requires neither the layout nor the <tt>Activity</tt> class be altered. Instead, the helper is set through the <tt>viewInflaterClass</tt> theme attribute, and tag matcher rules are defined in a resource XML file.</string>

    <string name="material_title"><tt>AppCompatActivity</tt></string>
    <string name="material_subtitle"><tt>Theme.MaterialComponents</tt></string>
    <string name="material_summary">This example sets the <tt>viewInflaterClass</tt> value in code, before <tt>super.onCreate()</tt>, and the <tt>TagMatcher</tt>s are defined programmatically.</string>

    <string name="unavailable_drawables">ShadowDrawable is unavailable on the current device.</string>
    <string name="unavailable_colors">Shadow colors are not available on the current API level.</string>
</resources>